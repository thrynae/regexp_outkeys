
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>function</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-10-20"><meta name="DC.source" content="regexp_outkeys.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>function</h1><!--introduction--><p><tt style="font-size:0%">Formatted documentation for the regexp_outkeys function.</tt>
<div style="margin-top:-5em;color:grey">Regexp with outkeys in old releases
</div>
</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Syntax</a></li><li><a href="#3">Output arguments</a></li><li><a href="#4">Input arguments</a></li><li><a href="#5">Example</a></li><li><a href="#6">Compatibility, version info, and licence</a></li><li><a href="#7">Test suite</a></li></ul></div><h2 id="1">Description</h2><p>
On older versions of Matlab the regexp function did not allow you to specify the output keys.
This function has an implementation of the <code>'split'</code> and <code>'match'</code> output
keys, so they can be used on any version of Matlab or GNU Octave.
<br>On releases where these outkeys are available, the builtin is called.
</p><h2 id="2">Syntax</h2><pre class="language-matlab">out=regexp_outkeys(str,expression,outkey);
[out1,<span class="keyword">...</span><span class="comment">,outN]=regexp_outkeys(str,expression,outkey1,...,outkeyN);</span>
[___,startIndex,endIndex]=regexp_outkeys(___);
</pre><h2 id="3">Output arguments</h2><p>
<table border=1>
<tr><td>
out
</td><td>
The result specified by the outkey:<br>
<code>'start'</code>: numeric array with the starting indices of the matches.<br>
<code>'end'</code>: numeric array with the ending indices of the matches.<br>
<code>'match'</code>: cellstr with the matches.<br>
<code>'split'</code>: cellstr with the non-matches.
</td></tr>
<tr><td>
startIndex
</td><td>
Same result as <code>'start'</code> outkey.
</td></tr>
<tr><td>
endIndex
</td><td>
Same result as <code>'end'</code> outkey.
</td></tr>
</table>
</p><h2 id="4">Input arguments</h2><p>
<table border=1>
<tr><td>
str
</td><td>
Char array containing the text to be searched.
</td></tr>
<tr><td>
expression
</td><td>
Regular expression. See the documentation for <code>regexp</code> for more explanation.
</td></tr>
<tr><td>
outkey
</td><td>
One of the supported outkeys: <code>'match'</code>, <code>'split'</code>, <code>'start'</code>,
and <code>'end'</code>.
</td></tr>
</table>
</p><h2 id="5">Example</h2><p>A few examples of valid syntax options:</p><pre class="codeinput">str=<span class="string">'lorem1 ipsum1.2 dolor3 sit amet 99 '</span>;
words=regexp_outkeys(str,<span class="string">' '</span>,<span class="string">'split'</span>)
numbers=regexp_outkeys(str,<span class="string">'[0-9.]*'</span>,<span class="string">'match'</span>)
[white,end1,start,end2]=regexp_outkeys(str,<span class="string">' '</span>,<span class="string">'match'</span>,<span class="string">'end'</span>)
</pre><h2 id="6">Compatibility, version info, and licence</h2><p>
Compatibility considerations:
<ul>
   <li>Only the <code>'match'</code>, <code>'split'</code>, <code>'start'</code>, and
      <code>'end'</code> options are supported. The additional options provided by regexp are
      also not implemented.</li>
   <li>Cell array input is not supported.</li>
</ul>
</p><p>
<table>
<tr>
<td> Test suite result </td>
<td style="border:2px solid black;"> Windows XP/7/10 </td>
<td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
<td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2021b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it>Pass</it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2021a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it>Pass</it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2019a </td>
<td> <it></it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2018a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2017b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2016b </td>
<td> <it></it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2016a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2015a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2013b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2012b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2012a </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2011a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010b </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010a </td>
<td> <it>W7 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2007b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
<td> <it>XP : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 6.3.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 6.2.0 </td>
<td> <it></it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 5.2.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 4.4.1 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
</table>
</p><pre>Version: 1.1.0
Date:    2021-10-20
Author:  H.J. Wisselink
Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
Email = 'h_j_wisselink*alumnus_utwente_nl';
Real_email = regexprep(Email,{'*','_'},{'@','.'})</pre><h2 id="7">Test suite</h2><p>This tester is included so you can test if your own modifications would introduce any bugs. These tests form the basis for the compatibility table above.</p><p>To save space, the tester function below was minified. The full tester function (including all comments) can be found <a href="https://web.archive.org/web/20211020175321/https://cdn-105.anonfiles.com/17D0k4P3u4/a8004d5c-1634752995/aaa___regexp_outkeys___test.m">here</a>.</p><pre class="codeinput"><span class="comment">% Test the supported output keys by comparing the output to pre-computed hashes.</span>
<span class="comment">%</span>
<span class="comment">% Pass:    passes all tests</span>
<span class="comment">% Partial: [no partial passing condition]</span>
<span class="comment">% Fail:    fails any test</span>
<span class="comment">%</span>
<span class="keyword">function</span> v000=aaa___regexp_outkeys___test(varargin),v000=<span class="string">'pass'</span>;<span class="keyword">try</span> v001=<span class="keyword">...</span>
<span class="string">'lorem1 ipsum1.2 dolor3 sit amet 99 '</span>;[v002,v003]=regexp_outkeys(v001,<span class="string">' '</span>,<span class="string">'split'</span>,<span class="string">'match'</span>);v004=<span class="keyword">...</span>
regexp_outkeys(v001,<span class="string">' '</span>,<span class="string">'split'</span>);v005=regexp_outkeys(v001,<span class="string">'[0-9.]*'</span>,<span class="string">'match'</span>);[v006,v007,v008,<span class="keyword">...</span>
v009]=regexp_outkeys(v001,<span class="string">' '</span>,<span class="string">'match'</span>,<span class="string">'end'</span>);[v010,v011]=regexp_outkeys(v001,<span class="string">' '</span>);<span class="keyword">catch</span>,<span class="keyword">...</span>
error(<span class="string">'syntax error'</span>),<span class="keyword">end</span>,v012={ v004(1:(end-1)) , v005 , v006 , {v008,v010,v007,v009,v011}};
v013=ComputeNonCryptHash(v012,128,<span class="string">'-v1'</span>);v014=<span class="string">'949A3362D4B92284FF5F22759724E19E'</span>;<span class="keyword">if</span> <span class="keyword">...</span>
~strcmp(v013,v014),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">else</span>,error(<span class="string">'test failed'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
disp([<span class="string">'tester function '</span> mfilename <span class="string">' finished '</span>]),<span class="keyword">if</span> nargout==0,clear,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);<span class="keyword">for</span> v004=<span class="keyword">...</span>
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_logical_to_uint16(v000),<span class="keyword">if</span> mod(numel(v000),16),<span class="keyword">...</span>
v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
<span class="keyword">try</span> v000=v000.*v001;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = <span class="keyword">...</span>
uint16(mod(double(v000) * v002 , v001));<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=<span class="keyword">...</span>
uint16(mod(double(v000) * v002,v001));<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_DefaultsByVersion(v000),<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'re_encode_char_on_Octave'</span>),v000.re_encode_char=v000.Version&gt;=2;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'string_to_cellstr'</span>),v000.string_to_cellstr=v000.Version&gt;=2;<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'cast_int64_double'</span>),v000.cast_int64_double=v000.Version==1;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=<span class="keyword">...</span>
struct;<span class="keyword">try</span> v003=str2double(v000.VersionFlag(3:end));<span class="keyword">if</span> isnan(v003) || round(v003)~=v003 || <span class="keyword">...</span>
v003&gt;2,error(<span class="string">'trigger'</span>);<span class="keyword">end</span>,v000.Version=v003;<span class="keyword">catch</span>,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Version input incorrect. Must be ''-v1'', ''-v2''.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,v004=v000.HashLength;
<span class="keyword">if</span> numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004&lt;16,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Second input (hash length) must be a multiple of 16.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=<span class="keyword">...</span>
fieldnames(v000.print_2__default_options),<span class="keyword">if</span> ~isequal(v000.(v005{1}),<span class="keyword">...</span>
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v006),v001.identifier=<span class="string">'HJW:ComputeNonCryptHash:PrintToIncorrect'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v000.print_2__options=v006;<span class="keyword">break</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag=<span class="string">'-v2'</span>;v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);<span class="keyword">end</span>,<span class="keyword">if</span> nargin==0,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v003);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,<span class="keyword">switch</span> class(varargin{1}),<span class="keyword">...</span>
<span class="keyword">case</span> {<span class="string">'char'</span>,<span class="string">'string'</span>},v001=AddMissing(v003,struct(<span class="string">'VersionFlag'</span>,char(varargin{1})));<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'struct'</span>,v001=AddMissing(v003,varargin{1});<span class="keyword">otherwise</span>,v001=AddMissing(v003,struct(<span class="string">'HashLength'</span>,<span class="keyword">...</span>
varargin{1}));<span class="keyword">end</span>,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> <span class="keyword">...</span>
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">try</span> [v001,v002,v005]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
<span class="keyword">catch</span>,v002.identifier=<span class="string">'HJW:ComputeNonCryptHash:InputFail'</span>;v002.message=<span class="keyword">...</span>
<span class="string">'Input parsing failed. Maybe a parameter has been entered twice.'</span>;v000=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~v000,<span class="keyword">...</span>
<span class="keyword">return</span>,<span class="keyword">else</span> ,v001=AddMissing(v003,v001);<span class="keyword">end</span>,[v001,v002,v000]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> v000,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_uint16_to_logical(v000),<span class="keyword">persistent</span> v001,<span class="keyword">if</span> isempty(v001),v001=<span class="keyword">...</span>
dec2bin(0:(-1+2^16))==<span class="string">'1'</span>;v001=v001.';<span class="keyword">end</span>,v000=double(v000)+1;v000=v001(:,v000);<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,<span class="keyword">...</span>
varargin),<span class="keyword">if</span> v002 || numel(varargin)==0,<span class="keyword">return</span>,<span class="keyword">end</span>,v003=varargin{1};<span class="keyword">if</span> isa(v003,<span class="string">'struct'</span>),v004=<span class="keyword">...</span>
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);<span class="keyword">if</span> numel(v004)+numel(v005) ~= <span class="keyword">...</span>
numel(v006),v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,v000=AddMissing(v000,v003);varargin(1)=[];<span class="keyword">elseif</span> isa(v003,<span class="keyword">...</span>
<span class="string">'char'</span>) || isa(v003,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">if</span> isa(v003,<span class="string">'string'</span>),v003=char(v003);<span class="keyword">end</span>,<span class="keyword">if</span> strcmpi(<span class="string">'-v'</span>,<span class="keyword">...</span>
v003(1:2)),<span class="keyword">if</span> isfield(v000,<span class="string">'VersionFlag'</span>),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.VersionFlag=v003;
varargin(1)=[];<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,v003),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.(v003)=varargin{2};
varargin(1:2)=[];<span class="keyword">end</span>,<span class="keyword">catch</span>,v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,<span class="string">'HashLength'</span>),v002=true;
<span class="keyword">return</span>,<span class="keyword">end</span>,v000.HashLength=v003;varargin(1)=[];<span class="keyword">end</span>,[v000,v001,v002]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});<span class="keyword">end</span>
<span class="keyword">function</span> error_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@error_);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v001),v001=validate_print_to__options(struct);<span class="keyword">end</span>,v001 =<span class="keyword">...</span>
parse_warning_error_redirect_options( v001 );[v002,v003,v004,v005,v006]=<span class="keyword">...</span>
parse_warning_error_redirect_inputs( varargin{:});<span class="keyword">if</span> v006,<span class="keyword">return</span>,<span class="keyword">end</span>,v007=struct(<span class="string">'identifier'</span>,<span class="keyword">...</span>
v002,<span class="string">'message'</span>,v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.obj,v008=v003;<span class="keyword">while</span> v008(end)==10,v008(end)=<span class="keyword">...</span>
<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> any(v008==10),v008=char2cellstr([<span class="string">'Error: '</span> v008]);<span class="keyword">else</span>,v008=[<span class="string">'Error: '</span> v008];<span class="keyword">end</span>,<span class="keyword">for</span> <span class="keyword">...</span>
v009=v001.obj(:).',<span class="keyword">try</span> set(v009,<span class="string">'String'</span>,v008);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> v010=<span class="keyword">...</span>
v001.fid(:).',<span class="keyword">try</span> fprintf(v010,<span class="string">'Error: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fcn,<span class="keyword">...</span>
<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v011=v001.fcn(:).',<span class="keyword">if</span> <span class="keyword">...</span>
isfield(v011,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v011.h,<span class="string">'error'</span>,v007,v011.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">try</span> feval(v011.h,<span class="keyword">...</span>
<span class="string">'error'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,rethrow(v007),<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=get_trace(v002,v001),<span class="keyword">if</span> nargin==0,v002=1;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;2, v001=dbstack;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(1:v002)=[];<span class="keyword">if</span> ~isfield(v001,<span class="string">'file'</span>),<span class="keyword">for</span> v003=1:numel(v001),v004=v001(v003).name;<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004(end),<span class="string">')'</span>),v005=strfind(v004,<span class="string">'('</span>);v006=v004( (v005(end)+1):(end-1) );v007=<span class="keyword">...</span>
v004(1:(v005(end)-2));<span class="keyword">else</span>,v007=v004;[v008,v006]=fileparts(v004);<span class="keyword">end</span>,[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v007);v001(v003).name=v006;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v009,<span class="keyword">if</span> isempty(v009),v009=<span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> v009,<span class="keyword">for</span> v003=1:numel(v001),[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v001(v003).file);<span class="keyword">end</span>,<span class="keyword">end</span>,v010=v001;v011=<span class="string">'&gt;'</span>;v000=cell(1,numel(v010)-1);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);<span class="keyword">if</span> v003==numel(v010),<span class="keyword">...</span>
v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> strcmp(v010(v003).file,v010(v003).name),v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file <span class="string">'&gt;'</span>];<span class="keyword">end</span>,v000{v003}=<span class="keyword">...</span>
sprintf(<span class="string">'%c In %s%s (line %d)\n'</span>,v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=<span class="string">' '</span>;
<span class="keyword">end</span>,v000=horzcat(v000{:});<span class="keyword">end</span>
<span class="keyword">function</span> v000=bsxfun_plus(v001,v002),<span class="keyword">try</span> v000=v001+v002;<span class="keyword">catch</span>,<span class="keyword">try</span> v000=bsxfun(@plus,v001,v002);
<span class="keyword">catch</span>,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,<span class="keyword">...</span>
max(1,v003./v004));v000=v001+v002;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector(v000,v001),<span class="keyword">if</span> isa(v000,<span class="string">'uint16'</span>),v002=<span class="string">'uint16'</span>;v003=<span class="keyword">...</span>
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];<span class="keyword">return</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];<span class="keyword">end</span>
<span class="keyword">function</span> v000=ifversion(v001,v002,v003,v004,v005),<span class="keyword">persistent</span> v006 v007 v008,<span class="keyword">if</span> isempty(v006),<span class="keyword">...</span>
v008=exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>);v006=version;v009=strfind(v006,<span class="string">'.'</span>);<span class="keyword">if</span> numel(v009)~=1,<span class="keyword">...</span>
v006(v009(2):end)=<span class="string">''</span>;v009=v009(1);<span class="keyword">end</span>,v006=[str2double(v006(1:(v009-1))) <span class="keyword">...</span>
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ <span class="string">'R13'</span> 605;
<span class="string">'R13SP1'</span> 605;<span class="string">'R13SP2'</span> 605;<span class="string">'R14'</span> 700;<span class="string">'R14SP1'</span> 700;<span class="string">'R14SP2'</span> 700;<span class="string">'R14SP3'</span> 701;<span class="string">'R2006a'</span> 702;
<span class="string">'R2006b'</span> 703;<span class="string">'R2007a'</span> 704;<span class="string">'R2007b'</span> 705;<span class="string">'R2008a'</span> 706;<span class="string">'R2008b'</span> 707;<span class="string">'R2009a'</span> 708;<span class="string">'R2009b'</span> 709;
<span class="string">'R2010a'</span> 710;<span class="string">'R2010b'</span> 711;<span class="string">'R2011a'</span> 712;<span class="string">'R2011b'</span> 713;<span class="string">'R2012a'</span> 714;<span class="string">'R2012b'</span> 800;<span class="string">'R2013a'</span> 801;
<span class="string">'R2013b'</span> 802;<span class="string">'R2014a'</span> 803;<span class="string">'R2014b'</span> 804;<span class="string">'R2015a'</span> 805;<span class="string">'R2015b'</span> 806;<span class="string">'R2016a'</span> 900;<span class="string">'R2016b'</span> 901;
<span class="string">'R2017a'</span> 902;<span class="string">'R2017b'</span> 903;<span class="string">'R2018a'</span> 904;<span class="string">'R2018b'</span> 905;<span class="string">'R2019a'</span> 906;<span class="string">'R2019b'</span> 907;<span class="string">'R2020a'</span> 908;
<span class="string">'R2020b'</span> 909;<span class="string">'R2021a'</span> 910;<span class="string">'R2021b'</span> 911};<span class="keyword">end</span>,<span class="keyword">if</span> v008,<span class="keyword">if</span> nargin==2,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NoOctaveTest'</span>,[<span class="string">'No version test for Octave was provided.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This function might return an unexpected outcome.'</span>]),<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> nargin==4,[v001,v010]=deal(v003,v004);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">else</span>,[v001,v010]=deal(v004,v005);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> v001,<span class="keyword">case</span> <span class="string">'=='</span>, v000= v006 == v010;<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'&lt;'</span> , v000= v006 &lt; v010;<span class="keyword">case</span> <span class="string">'&lt;='</span>, v000= v006 &lt;= v010;<span class="keyword">case</span> <span class="string">'&gt;'</span> , v000= v006 &gt; v010;<span class="keyword">case</span> <span class="string">'&gt;='</span>, <span class="keyword">...</span>
v000= v006 &gt;= v010;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,<span class="keyword">...</span>
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,<span class="keyword">...</span>
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);<span class="keyword">if</span> <span class="keyword">...</span>
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v002=uint16(2.^(15:-1:0))';v000=<span class="keyword">...</span>
uint16(reshape(v000,16,[]));<span class="keyword">try</span> v000=v000.*v002;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v002),[1 <span class="keyword">...</span>
size(v000,2)]);v000=uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,<span class="keyword">...</span>
2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=ifversion(<span class="string">'&gt;='</span>,<span class="string">'R2010b'</span>,<span class="string">'Octave'</span>,<span class="string">'&gt;'</span>,0);<span class="keyword">end</span>,v004=<span class="keyword">...</span>
class(v000);v005=~v001.cast_int64_double &amp;&amp; v003 &amp;&amp; v004(end)==<span class="string">'4'</span>;<span class="keyword">if</span> ~v005,<span class="keyword">if</span> <span class="keyword">...</span>
any(abs(double(v000(:)))&gt;2^52),warning_(v001,<span class="string">'HJW:ComputeNonCryptHash:int64rounding'</span>,<span class="keyword">...</span>
[<span class="string">'int64 and uint64 will be rounded pre-R2010b, resulting in rounding.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This will result in a hash that is different from newer releases.'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v005,<span class="keyword">if</span> <span class="keyword">...</span>
v004(1)~=<span class="string">'u'</span>,v006=v000&gt;0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=<span class="keyword">...</span>
uint64(v000(v006))+uint64(v007)+1;v000=v008;<span class="keyword">end</span>,<span class="keyword">elseif</span> v004(1)~=<span class="string">'u'</span>,v000=<span class="keyword">...</span>
double(v000)-double(eval([v004 <span class="string">'(-inf)'</span>]));<span class="keyword">else</span>,v000=double(v000);<span class="keyword">end</span>,<span class="keyword">switch</span> v004(end),<span class="keyword">case</span> <span class="string">'8'</span>,<span class="keyword">...</span>
<span class="keyword">if</span> mod(numel(v000),2),v000(end+1)=0;<span class="keyword">end</span>,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);<span class="keyword">case</span> <span class="string">'6'</span>,v000=uint16(v000);<span class="keyword">case</span> <span class="string">'2'</span>,v009=floor(v000/2^16);v009=v009.';v010=<span class="keyword">...</span>
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));<span class="keyword">case</span> <span class="string">'4'</span>,v011=v000;v012=<span class="keyword">...</span>
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=<span class="keyword">...</span>
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));<span class="keyword">end</span>,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=char2cellstr(v001,v002),v003=isa(v001,<span class="string">'char'</span>);v001=int32(v001);<span class="keyword">if</span> nargin&lt;2,<span class="keyword">if</span> <span class="keyword">...</span>
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(v001==10)=-10;<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),<span class="keyword">...</span>
int32(-10));<span class="keyword">end</span>,<span class="keyword">end</span>,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);<span class="keyword">for</span> v004=<span class="keyword">...</span>
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);<span class="keyword">end</span>,<span class="keyword">if</span> v003,<span class="keyword">...</span>
<span class="keyword">for</span> v004=1:numel(v000),v000{v004}= char(v000{v004});<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
uint32(v000{v004});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=CharIsUTF8,<span class="keyword">persistent</span> v001,<span class="keyword">if</span> isempty(v001),<span class="keyword">if</span> exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>)~=<span class="keyword">...</span>
0,v002=struct(<span class="string">'w'</span>,warning(<span class="string">'off'</span>,<span class="string">'all'</span>));[v002.msg,v002.ID]=lastwarn;v001=~isequal(8364,<span class="keyword">...</span>
double(char(8364)));warning(v002.w);lastwarn(v002.msg,v002.ID);<span class="keyword">else</span>,v001=false;<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
v001;<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash(v001,varargin),<span class="keyword">if</span> nargin&lt;1,<span class="keyword">...</span>
error(<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>,<span class="string">'At least 1 input required.'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> nargin==2 <span class="keyword">...</span>
&amp;&amp; isa(varargin{1},<span class="string">'struct'</span>) &amp;&amp; varargin{1}.SkipInputParse,v002=varargin{1};<span class="keyword">else</span>,[v003,v002,<span class="keyword">...</span>
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});<span class="keyword">if</span> ~v003,rethrow(v004),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;<span class="keyword">try</span> v004=[];v001=<span class="keyword">...</span>
cast_to_uint16_vector(v001,v002);<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004.identifier,<span class="string">'MATLAB:nomem'</span>),error_(v002.print_to,v004),<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v002,<span class="string">'debug'</span>) <span class="keyword">...</span>
&amp;&amp; v002.debug,v007=sprintf(<span class="string">'\n[original error: %s %s]'</span>,v004.identifier,v004.message);<span class="keyword">else</span>,v007=<span class="keyword">...</span>
<span class="string">''</span>;<span class="keyword">end</span>,error_(v002.print_to,<span class="string">'HJW:ComputeNonCryptHash:UnwindFailed'</span>,<span class="keyword">...</span>
[<span class="string">'The nested input contains an unsupported data type.'</span> v007]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> mod(numel(v001),<span class="keyword">...</span>
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=<span class="keyword">...</span>
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');<span class="keyword">else</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=<span class="keyword">...</span>
circshift_by_col(v001);<span class="keyword">end</span>,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=<span class="keyword">...</span>
ComputeNonCryptHash_logical_to_uint16(v001);<span class="keyword">if</span> v002.isSaltCall,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=<span class="keyword">...</span>
reshape(v000.',1,[]);<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v000),<span class="keyword">if</span> numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> class(v000{v003}),<span class="keyword">case</span> {<span class="string">'double'</span>,<span class="string">'single'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__floats(v000{v003});<span class="keyword">case</span> <span class="string">'logical'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__logical(v000{v003});<span class="keyword">case</span> {<span class="string">'uint8'</span>,<span class="string">'uint16'</span>,<span class="string">'uint32'</span>,<span class="string">'uint64'</span>,<span class="string">'int8'</span>,<span class="keyword">...</span>
<span class="string">'int16'</span>,<span class="string">'int32'</span>,<span class="string">'int64'</span>},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);<span class="keyword">case</span> <span class="string">'char'</span>,<span class="keyword">...</span>
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);<span class="keyword">case</span> <span class="string">'string'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__string(v000{v003},v001);<span class="keyword">case</span> <span class="string">'cell'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell(v000{v003},v001);<span class="keyword">case</span> <span class="string">'struct'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__struct(v000{v003},v001);<span class="keyword">case</span> {<span class="string">'gpuArray'</span>,<span class="string">'tall'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell({gather(v000{v003})},v001);<span class="keyword">otherwise</span>,error_(v001.print_to,<span class="keyword">...</span>
<span class="string">'HJW:cast_to_uint16_vector:nosupport'</span>,<span class="string">'Unsupported data type in nested variable'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__char(v000,v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> v002 &amp;&amp; v001.re_encode_char,v003 = size(v000,1)==<span class="keyword">...</span>
numel(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,v000=cellstr(v000);<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);<span class="keyword">end</span>,v005=cellfun(<span class="string">'length'</span>,v000);
v006=max(v005);<span class="keyword">for</span> v004=find(v005&lt;v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(<span class="string">' '</span>);
<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,<span class="keyword">end</span>,v007=size(v000).';v000=v000(:);v000=<span class="keyword">...</span>
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=<span class="keyword">...</span>
fieldnames(v000);v004=cell(2,numel(v003));<span class="keyword">for</span> v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,<span class="keyword">...</span>
v005}={v000.(v003{v005})};<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__string(v000,v001),<span class="keyword">if</span> v001.string_to_cellstr,v000=<span class="keyword">...</span>
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);<span class="keyword">else</span>,v000=char(v000);v000=<span class="keyword">...</span>
cast_to_uint16_vector__char(v000,v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002,v003,v004]=parse_warning_error_redirect_inputs(varargin),v004=false;<span class="keyword">if</span> <span class="keyword">...</span>
nargin==1,<span class="keyword">if</span> isa(varargin{1},<span class="string">'struct'</span>) || isa(varargin{1},<span class="string">'MException'</span>),v005=varargin{1};<span class="keyword">if</span> <span class="keyword">...</span>
numel(v005)==0,v004=true;[v000,v001,v002,v003]=deal(<span class="string">''</span>);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">try</span> v002=v005.stack;v003=<span class="keyword">...</span>
get_trace(0,v002);<span class="keyword">catch</span>,[v003,v002]=get_trace(3);<span class="keyword">end</span>,v000=v005.identifier;v001=v005.message;
v006=<span class="string">'Error using &lt;a href="matlab:matlab.internal.language.introspective.errorDocCallback('</span>;<span class="keyword">if</span> <span class="keyword">...</span>
isa(v005,<span class="string">'struct'</span>) &amp;&amp; numel(v001)&gt;numel(v006) &amp;&amp; strcmp(v006,v001(1:numel(v006))),<span class="keyword">...</span>
v001(1:find(v001==10,1))=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);[v000,v001]=deal(<span class="string">''</span>,varargin{1});
<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);<span class="keyword">if</span> ~isempty(strfind(varargin{1},<span class="string">'%'</span>)),v000=<span class="string">''</span>;v007=<span class="keyword">...</span>
varargin(2:end);v001=sprintf(varargin{1},v007{:});<span class="keyword">else</span>,v000=varargin{1};v001=varargin{2};<span class="keyword">if</span> <span class="keyword">...</span>
nargin&gt;2,v007=varargin(3:end);v001=sprintf(v001,v007{:});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=parse_warning_error_redirect_options(v000),<span class="keyword">if</span> ~isfield(v000,<span class="string">'boolean'</span>),<span class="keyword">...</span>
v000.boolean=struct;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'con'</span>) || isempty(v000.boolean.con),<span class="keyword">...</span>
v000.boolean.con=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'fid'</span>) || isempty(v000.boolean.fid),<span class="keyword">...</span>
v000.boolean.fid=isfield(v000,<span class="string">'fid'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'obj'</span>) || <span class="keyword">...</span>
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,<span class="string">'obj'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="keyword">...</span>
<span class="string">'fcn'</span>) || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,<span class="string">'fcn'</span>);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=PatternReplace(v001,v002,v003),v000=v001(:)';<span class="keyword">if</span> numel(v002)==0,v004=<span class="keyword">...</span>
false(size(v001));<span class="keyword">elseif</span> numel(v003)&gt;numel(v002),error(<span class="string">'not implemented (padding required)'</span>),<span class="keyword">...</span>
<span class="keyword">else</span>,v004=true(size(v001));<span class="keyword">for</span> v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006&lt;1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 &amp; v007;<span class="keyword">if</span> ~any(v004),<span class="keyword">break</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v006=find(v004);<span class="keyword">if</span> ~isempty(v006),<span class="keyword">for</span> v005=1:numel(v003),v000(v006+v005-1)=<span class="keyword">...</span>
v003(v005);<span class="keyword">end</span>,<span class="keyword">if</span> numel(v003)==0,v005=0;<span class="keyword">end</span>,<span class="keyword">if</span> numel(v002)&gt;v005,v006=v006(:);v008=<span class="keyword">...</span>
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> varargout=regexp_outkeys(v000,v001,varargin),<span class="keyword">if</span> nargin&lt;2,<span class="keyword">...</span>
error(<span class="string">'HJW:regexp_outkeys:SyntaxError'</span>,<span class="string">'No supported syntax used: at least 3 inputs expected.'</span>),<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">if</span> ~(ischar(v000) &amp;&amp; ischar(v001)),error(<span class="string">'HJW:regexp_outkeys:InputError'</span>,<span class="keyword">...</span>
<span class="string">'All inputs must be char vectors.'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> nargout&gt;nargin,error(<span class="string">'HJW:regexp_outkeys:ArgCount'</span>,<span class="keyword">...</span>
<span class="string">'Incorrect number of output arguments. Check syntax.'</span>),<span class="keyword">end</span>,<span class="keyword">persistent</span> v002 v003,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v002),v002.match = ifversion(<span class="string">'&lt;'</span>,<span class="string">'R14'</span>,<span class="string">'Octave'</span>,<span class="string">'&lt;'</span>,4);v002.split = ifversion(<span class="string">'&lt;'</span>,<span class="keyword">...</span>
<span class="string">'R2007b'</span>,<span class="string">'Octave'</span>,<span class="string">'&lt;'</span>,4);v004=fieldnames(v002);v003=<span class="keyword">...</span>
[<span class="string">'Extra regexp output type not implemented,'</span>,char(10),<span class="string">'only the following'</span>,<span class="keyword">...</span>
<span class="string">' types are implemented:'</span>,char(10),sprintf(<span class="string">'%s, '</span>,v004{:})];v003((end-1):end)=<span class="string">''</span>;v002.any = <span class="keyword">...</span>
v002.match || v002.split;<span class="keyword">end</span>,<span class="keyword">if</span> v002.any || nargin==2,[v005,v006]=regexp(v000,v001);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
nargin==2,varargout={v005,v006};<span class="keyword">return</span>,<span class="keyword">end</span>,varargout=cell(size(varargin));<span class="keyword">for</span> v007=1:(nargin-2),<span class="keyword">...</span>
<span class="keyword">if</span> ~ischar(varargin{v007}),error(<span class="string">'HJW:regexp_outkeys:InputError'</span>,<span class="keyword">...</span>
<span class="string">'All inputs must be char vectors.'</span>),<span class="keyword">end</span>,<span class="keyword">switch</span> lower(varargin{v007}),<span class="keyword">case</span> <span class="string">'match'</span>,<span class="keyword">if</span> v002.match,<span class="keyword">...</span>
v008=cell(1,numel(v005));<span class="keyword">for</span> v009=1:numel(v005),v008{v009}=v000(v005(v009):v006(v009));<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
[v008,v005,v006]=regexp(v000,v001,<span class="string">'match'</span>);<span class="keyword">end</span>,varargout{v007}=v008;<span class="keyword">case</span> <span class="string">'split'</span>,<span class="keyword">if</span> v002.split,<span class="keyword">...</span>
v010=cell(1,numel(v005)+1);v011=[v005 numel(v000)+1];v012=[0 v006];<span class="keyword">for</span> v009=1:numel(v011),<span class="keyword">...</span>
v010{v009}=v000((v012(v009)+1):(v011(v009)-1));<span class="keyword">end</span>,<span class="keyword">else</span>,[v010,v005,v006]= regexp(v000,v001,<span class="keyword">...</span>
<span class="string">'split'</span>);<span class="keyword">end</span>,varargout{v007}=v010;<span class="keyword">case</span> <span class="string">'start'</span>,varargout{v007}=v005;<span class="keyword">case</span> <span class="string">'end'</span>,varargout{v007}=<span class="keyword">...</span>
v006;<span class="keyword">otherwise</span>,error(<span class="string">'HJW:regexp_outkeys:NotImplemented'</span>,v003),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargout&gt;v007,<span class="keyword">...</span>
varargout(v007+[1 2])={v005,v006};<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=test_if_scalar_logical(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002={true,<span class="keyword">...</span>
false;1,0;<span class="string">'on'</span>,<span class="string">'off'</span>;<span class="string">'enable'</span>,<span class="string">'disable'</span>;<span class="string">'enabled'</span>,<span class="string">'disabled'</span>};<span class="keyword">try</span> v002(end+1,:)=<span class="keyword">...</span>
eval(<span class="string">'{"on","off"}'</span>);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v000=true;<span class="keyword">try</span> <span class="keyword">if</span> isa(v001,<span class="string">'char'</span>) || isa(v001,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">...</span>
v001=lower(v001);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v003=1:size(v002,1),<span class="keyword">for</span> v004=1:2,<span class="keyword">if</span> isequal(v001,v002{v003,<span class="keyword">...</span>
v004}),v001=v002{1,v004};<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> isa(v001,<span class="string">'matlab.lang.OnOffSwitchState'</span>),v001=<span class="keyword">...</span>
logical(v001);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,v000=false;<span class="keyword">end</span>
<span class="keyword">function</span> v000=circshift_by_col(v000),<span class="keyword">persistent</span> v001,v002=size(v000);<span class="keyword">if</span> isempty(v001) || <span class="keyword">...</span>
any(size(v001)&lt;v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),<span class="keyword">...</span>
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);<span class="keyword">if</span> <span class="keyword">...</span>
prod(v002)&lt;=1000,v001{v002(1),v002(2)}=v006;<span class="keyword">end</span>,<span class="keyword">else</span>,v006=v001{v002(1),v002(2)};<span class="keyword">end</span>,v000=<span class="keyword">...</span>
v000(v006);<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =<span class="keyword">...</span>
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=<span class="keyword">...</span>
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=<span class="keyword">...</span>
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 &amp; v002&gt;0)=<span class="keyword">...</span>
9218868437227405312;v000(v008 &amp; v002&lt;0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=<span class="keyword">...</span>
0;v001(v008)=0;<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_char(v001,v002),<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,v002=~CharIsUTF8;<span class="keyword">end</span>,<span class="keyword">if</span> v002,<span class="keyword">if</span> <span class="keyword">...</span>
all(v001&lt;65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,v006]=<span class="keyword">...</span>
unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">end</span>,<span class="keyword">if</span> ~v003,v000=char(v000);
<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> all(v001&lt;128),v000=char(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,<span class="keyword">...</span>
v006]=unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=<span class="keyword">...</span>
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);
v000=char(v000);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF16(v001),<span class="keyword">if</span> v001&lt;65536,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec([<span class="string">'110110'</span> v002(1:10);<span class="string">'110111'</span> v002(11:20)]).';<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001=<span class="string">'success'</span>;v002=<span class="keyword">...</span>
struct(<span class="string">'identifier'</span>,<span class="string">'HJW:UTF8_to_unicode:notUTF8'</span>,<span class="string">'message'</span>,<span class="string">'Input is not UTF-8.'</span>);<span class="keyword">persistent</span> <span class="keyword">...</span>
v004,<span class="keyword">if</span> isempty(v004),v004 = exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> any(v000&gt;255),v001=<span class="keyword">...</span>
<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> all(v000&lt;128),<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=4:-1:2,v006=<span class="keyword">...</span>
bin2dec([repmat(<span class="string">'1'</span>,1,v005) repmat(<span class="string">'0'</span>,1,8-v005)]);v007=v000&gt;=v006 &amp; v000&lt;256;<span class="keyword">if</span> any(v007),v007=<span class="keyword">...</span>
find(v007);v007=v007(:).';<span class="keyword">if</span> numel(v000)&lt;(max(v007)+v005-1),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v007( (v007+v005-1)&gt;numel(v000) )=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isempty(v007),v008=bsxfun_plus(v007 , <span class="keyword">...</span>
(0:(v005-1)).' );v008=v008.';v007=v000(v008);<span class="keyword">end</span>,<span class="keyword">else</span>,v007=[];<span class="keyword">end</span>,v009=[repmat(<span class="string">'1'</span>,1,v005-1) <span class="keyword">...</span>
repmat(<span class="string">'10'</span>,1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);<span class="keyword">if</span> numel(v007)&gt;0,v007=<span class="keyword">...</span>
unique(v007,<span class="string">'rows'</span>);v011=mat2cell(v007,ones(size(v007,1),1),v005);<span class="keyword">for</span> v012=1:numel(v011),v013=<span class="keyword">...</span>
dec2bin(double(v011{v012}))';<span class="keyword">if</span> ~strcmp(v009,v013(v010)),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">continue</span>,<span class="keyword">end</span>,v013(v010)=<span class="string">''</span>;<span class="keyword">if</span> ~v004,v014=uint32(bin2dec(v013 ));<span class="keyword">else</span>,v014=<span class="keyword">...</span>
uint32(bin2dec(v013.'));<span class="keyword">end</span>,v000=PatternReplace(v000,v011{v012},v014);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF8(v001),<span class="keyword">if</span> numel(v001)&gt;1,<span class="keyword">...</span>
error(<span class="string">'this should only be used for single characters'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> v001&lt;128,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=struct;v002.limits.lower=hex2dec({<span class="string">'0000'</span>,<span class="string">'0080'</span>,<span class="string">'0800'</span>, <span class="keyword">...</span>
<span class="string">'10000'</span>});v002.limits.upper=hex2dec({<span class="string">'007F'</span>,<span class="string">'07FF'</span>,<span class="string">'FFFF'</span>,<span class="string">'10FFFF'</span>});v002.scheme{2}=<span class="keyword">...</span>
<span class="string">'110xxxxx10xxxxxx'</span>;v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}=<span class="keyword">...</span>
<span class="string">'1110xxxx10xxxxxx10xxxxxx'</span>;v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}=<span class="keyword">...</span>
<span class="string">'11110xxx10xxxxxx10xxxxxx10xxxxxx'</span>;v002.scheme{4}=reshape(v002.scheme{4}.',8,4);<span class="keyword">for</span> v003=2:4,<span class="keyword">...</span>
v002.scheme_pos{v003}=find(v002.scheme{v003}==<span class="string">'x'</span>);v002.bits(v003)=numel(v002.scheme_pos{v003});
<span class="keyword">end</span>,<span class="keyword">end</span>,v004=find(v002.limits.lower&lt;=v001 &amp; v001&lt;=v002.limits.upper);v000=v002.scheme{v004};
v005=v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=<span class="keyword">...</span>
bin2dec(v000.').';<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode(v003,v004),<span class="keyword">if</span> nargin&lt;2,v004=[];<span class="keyword">end</span>,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);<span class="keyword">if</span> strcmp(v006,<span class="keyword">...</span>
<span class="string">'success'</span>),v001=true;v000=v002;<span class="keyword">elseif</span> strcmp(v006,<span class="string">'error'</span>),v001=false;<span class="keyword">if</span> v005,error_(v004,v007),<span class="keyword">...</span>
<span class="keyword">end</span>,v000=v003;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=<span class="keyword">...</span>
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);<span class="keyword">if</span> <span class="keyword">...</span>
v001.Version&gt;1,v004=v004(end:-1:1);<span class="keyword">end</span>,v000=mod(double(v000).*double(v004),1+2^16);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_dec2hex(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=<span class="keyword">...</span>
upper(dec2hex(0:(-1+2^16),4));<span class="keyword">end</span>,v001=double(v001)+1;v000=v002(v001,:);<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=validate_print_to__options(v002,v001),<span class="keyword">if</span> nargin&lt;2,v001=struct;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_con'</span>),v002.print_to_con=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_fid'</span>),<span class="keyword">...</span>
v002.print_to_fid=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_obj'</span>),v002.print_to_obj=[];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_fcn'</span>),v002.print_to_fcn=[];<span class="keyword">end</span>,v003=true;v000=struct;v004=<span class="keyword">...</span>
v002.print_to_fid;<span class="keyword">if</span> isempty(v004),v000.boolean.fid=false;v000.fid=[];<span class="keyword">else</span>,v003=false;
v000.boolean.fid=true;v000.fid=v004;<span class="keyword">for</span> v005=1:numel(v004),<span class="keyword">try</span> v006=ftell(v004(v005));<span class="keyword">catch</span>,<span class="keyword">...</span>
v006=-1;<span class="keyword">end</span>,<span class="keyword">if</span> v004(v005)~=1 &amp;&amp; v006==-1,v001.message=[<span class="string">'Invalid print_to_fid parameter:'</span>,<span class="keyword">...</span>
char(10),<span class="string">'should be a valid file identifier or 1.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=<span class="keyword">...</span>
v002.print_to_obj;<span class="keyword">if</span> isempty(v004),v000.boolean.obj=false;v000.obj=[];<span class="keyword">else</span>,v003=false;
v000.boolean.obj=true;v000.obj=v004;<span class="keyword">for</span> v005=1:numel(v004),<span class="keyword">try</span> v007=get(v004(v005),<span class="string">'String'</span> );
set( v004(v005),<span class="string">'String'</span>,<span class="string">''</span> );set( v004(v005),<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,v001.message=<span class="keyword">...</span>
[<span class="string">'Invalid print_to_obj parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a handle to an object with a writeable String property.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v004=v002.print_to_fcn;<span class="keyword">if</span> isempty(v004),v000.boolean.fcn=false;v000.fcn=[];<span class="keyword">else</span>,v003=false;<span class="keyword">try</span> <span class="keyword">...</span>
<span class="keyword">for</span> v005=1:numel(v004),<span class="keyword">if</span> ~ismember(class(v004(v005).h),{<span class="string">'function_handle'</span>,<span class="string">'inline'</span>}) || <span class="keyword">...</span>
numel(v004(v005).h)~=1,error(<span class="string">'trigger error'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,v001.message=<span class="keyword">...</span>
[<span class="string">'Invalid print_to_fcn parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a struct with the h field containing a function handle,'</span>,char(10),<span class="keyword">...</span>
<span class="string">'anonymous function or inline function.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v002.print_to_con;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v004),v000.boolean.con=v003;<span class="keyword">else</span>,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
<span class="keyword">if</span> ~v008,v001.message=[<span class="string">'Invalid print_to_con parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a scalar logical.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> warning_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@warning_);<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> isempty(v001),v001=validate_print_to__options(struct);<span class="keyword">end</span>,v001 =<span class="keyword">...</span>
parse_warning_error_redirect_options( v001 );[v002,v003,v004,v005,v006]=<span class="keyword">...</span>
parse_warning_error_redirect_inputs( varargin{:});<span class="keyword">if</span> v006,<span class="keyword">return</span>,<span class="keyword">end</span>,v007=struct(<span class="string">'identifier'</span>,<span class="keyword">...</span>
v002,<span class="string">'message'</span>,v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.con,<span class="keyword">if</span> ~isempty(v002),warning(v002,<span class="string">'%s'</span>,v003),<span class="keyword">...</span>
<span class="keyword">else</span>,warning(v003), <span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> ~isempty(v002),lastwarn(v003,v002); <span class="keyword">else</span>,lastwarn(v003),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> v001.boolean.obj,v008=v003;<span class="keyword">while</span> v008(end)==10,v008(end)=[];<span class="keyword">end</span>,<span class="keyword">if</span> any(v008==10),v008=<span class="keyword">...</span>
char2cellstr([<span class="string">'Warning: '</span> v008]);<span class="keyword">else</span>,v008=[<span class="string">'Warning: '</span> v008];<span class="keyword">end</span>,set(v001.obj,<span class="string">'String'</span>,v008),<span class="keyword">...</span>
<span class="keyword">for</span> v009=v001.obj(:).',<span class="keyword">try</span> set(v009,<span class="string">'String'</span>,v008);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> <span class="keyword">...</span>
v010=v001.fid(:).',<span class="keyword">try</span> fprintf(v010,<span class="string">'Warning: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.boolean.fcn,<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v011=<span class="keyword">...</span>
v001.fcn(:).',<span class="keyword">if</span> isfield(v011,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v007,v011.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% function
%
% <html><tt style="font-size:0%">Formatted documentation for the regexp_outkeys function.</tt>
% <div style="margin-top:-5em;color:grey">Regexp with outkeys in old releases
% </div>
% </html>

%% Description
% <html>
% On older versions of Matlab the regexp function did not allow you to specify the output keys.
% This function has an implementation of the <code>'split'</code> and <code>'match'</code> output
% keys, so they can be used on any version of Matlab or GNU Octave.
% <br>On releases where these outkeys are available, the builtin is called.
% </html>

%% Syntax
%
%   out=regexp_outkeys(str,expression,outkey);
%   [out1,...,outN]=regexp_outkeys(str,expression,outkey1,...,outkeyN);
%   [___,startIndex,endIndex]=regexp_outkeys(___);

%% Output arguments
%
% <html>
% <table border=1>
% <tr><td>
% out
% </td><td>
% The result specified by the outkey:<br>
% <code>'start'</code>: numeric array with the starting indices of the matches.<br>
% <code>'end'</code>: numeric array with the ending indices of the matches.<br>
% <code>'match'</code>: cellstr with the matches.<br>
% <code>'split'</code>: cellstr with the non-matches.
% </td></tr>
% <tr><td>
% startIndex
% </td><td>
% Same result as <code>'start'</code> outkey.
% </td></tr>
% <tr><td>
% endIndex
% </td><td>
% Same result as <code>'end'</code> outkey.
% </td></tr>
% </table>
% </html>

%% Input arguments
%
% <html>
% <table border=1>
% <tr><td>
% str
% </td><td>
% Char array containing the text to be searched.
% </td></tr>
% <tr><td>
% expression
% </td><td>
% Regular expression. See the documentation for <code>regexp</code> for more explanation.
% </td></tr>
% <tr><td>
% outkey
% </td><td>
% One of the supported outkeys: <code>'match'</code>, <code>'split'</code>, <code>'start'</code>,
% and <code>'end'</code>.
% </td></tr>
% </table>
% </html>

%% Example
%
% A few examples of valid syntax options:

str='lorem1 ipsum1.2 dolor3 sit amet 99 ';
words=regexp_outkeys(str,' ','split')
numbers=regexp_outkeys(str,'[0-9.]*','match')
[white,end1,start,end2]=regexp_outkeys(str,' ','match','end')

%% Compatibility, version info, and licence
% <html>
% Compatibility considerations:
% <ul>
%    <li>Only the <code>'match'</code>, <code>'split'</code>, <code>'start'</code>, and
%       <code>'end'</code> options are supported. The additional options provided by regexp are
%       also not implemented.</li>
%    <li>Cell array input is not supported.</li>
% </ul>
% </html>
% 
% <html>
% <table>
% <tr>
% <td> Test suite result </td>
% <td style="border:2px solid black;"> Windows XP/7/10 </td>
% <td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
% <td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2021b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2021a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2019a </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2018a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2017b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2016b </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2016a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2015a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2013b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2012b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2012a </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2011a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010b </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010a </td>
% <td> <it>W7 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2007b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
% <td> <it>XP : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 6.3.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 6.2.0 </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 5.2.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 4.4.1 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% </table>
% </html>
%
%  Version: 1.1.0
%  Date:    2021-10-20
%  Author:  H.J. Wisselink
%  Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
%  Email = 'h_j_wisselink*alumnus_utwente_nl';
%  Real_email = regexprep(Email,{'*','_'},{'@','.'})

%% Test suite
%
% This tester is included so you can test if your own modifications would introduce any bugs. These
% tests form the basis for the compatibility table above.
% 
% To save space, the tester function below was minified. The full tester function (including all comments) can be found <https://web.archive.org/web/20211020175321/https://cdn-105.anonfiles.com/17D0k4P3u4/a8004d5c-1634752995/aaa___regexp_outkeys___test.m here>.

% Test the supported output keys by comparing the output to pre-computed hashes.
% 
% Pass:    passes all tests
% Partial: [no partial passing condition]
% Fail:    fails any test
%
function v000=aaa___regexp_outkeys___test(varargin),v000='pass';try v001=...
'lorem1 ipsum1.2 dolor3 sit amet 99 ';[v002,v003]=regexp_outkeys(v001,' ','split','match');v004=...
regexp_outkeys(v001,' ','split');v005=regexp_outkeys(v001,'[0-9.]*','match');[v006,v007,v008,...
v009]=regexp_outkeys(v001,' ','match','end');[v010,v011]=regexp_outkeys(v001,' ');catch,...
error('syntax error'),end,v012={ v004(1:(end-1)) , v005 , v006 , {v008,v010,v007,v009,v011}};
v013=ComputeNonCryptHash(v012,128,'-v1');v014='949A3362D4B92284FF5F22759724E19E';if ...
~strcmp(v013,v014),if nargout>0,v000='fail';else,error('test failed'),end,end,...
disp(['tester function ' mfilename ' finished ']),if nargout==0,clear,end,end
function v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);for v004=...
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);end,end
function v000=ComputeNonCryptHash_logical_to_uint16(v000),if mod(numel(v000),16),...
v000(16*ceil(numel(v000)/16))=0;end,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
try v000=v000.*v001;catch,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=...
uint16(v000);end,v000=uint16(sum(v000,1)).';end
function v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = ...
uint16(mod(double(v000) * v002 , v001));end
function v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=...
uint16(mod(double(v000) * v002,v001));end
function v000=ComputeNonCryptHash_DefaultsByVersion(v000),if ~isfield(v000,...
're_encode_char_on_Octave'),v000.re_encode_char=v000.Version>=2;end,if ~isfield(v000,...
'string_to_cellstr'),v000.string_to_cellstr=v000.Version>=2;if ~isfield(v000,...
'cast_int64_double'),v000.cast_int64_double=v000.Version==1;end,end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=...
struct;try v003=str2double(v000.VersionFlag(3:end));if isnan(v003) || round(v003)~=v003 || ...
v003>2,error('trigger');end,v000.Version=v003;catch,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Version input incorrect. Must be ''-v1'', ''-v2''.';v002=false;return,end,v004=v000.HashLength;
if numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004<16,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Second input (hash length) must be a multiple of 16.';v002=false;return,end,for v005=...
fieldnames(v000.print_2__default_options),if ~isequal(v000.(v005{1}),...
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);if ...
isempty(v006),v001.identifier='HJW:ComputeNonCryptHash:PrintToIncorrect';v002=false;return,end,...
v000.print_2__options=v006;break,end,end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
persistent v003,if isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag='-v2';v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);end,if nargin==0,v001=...
ComputeNonCryptHash_DefaultsByVersion(v003);return,end,if nargin==1,switch class(varargin{1}),...
case {'char','string'},v001=AddMissing(v003,struct('VersionFlag',char(varargin{1})));case ...
'struct',v001=AddMissing(v003,varargin{1});otherwise,v001=AddMissing(v003,struct('HashLength',...
varargin{1}));end,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if ...
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);end,return,end,try [v001,v002,v005]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
catch,v002.identifier='HJW:ComputeNonCryptHash:InputFail';v002.message=...
'Input parsing failed. Maybe a parameter has been entered twice.';v000=false;end,if ~v000,...
return,else ,v001=AddMissing(v003,v001);end,[v001,v002,v000]=...
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if v000,v001=...
ComputeNonCryptHash_DefaultsByVersion(v001);end,end
function v000=ComputeNonCryptHash_uint16_to_logical(v000),persistent v001,if isempty(v001),v001=...
dec2bin(0:(-1+2^16))=='1';v001=v001.';end,v000=double(v000)+1;v000=v001(:,v000);end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,...
varargin),if v002 || numel(varargin)==0,return,end,v003=varargin{1};if isa(v003,'struct'),v004=...
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);if numel(v004)+numel(v005) ~= ...
numel(v006),v002=true;return,end,v000=AddMissing(v000,v003);varargin(1)=[];elseif isa(v003,...
'char') || isa(v003,'string'),try if isa(v003,'string'),v003=char(v003);end,if strcmpi('-v',...
v003(1:2)),if isfield(v000,'VersionFlag'),error('trigger'),end,v000.VersionFlag=v003;
varargin(1)=[];else,if isfield(v000,v003),error('trigger'),end,v000.(v003)=varargin{2};
varargin(1:2)=[];end,catch,v002=true;return,end,else,if isfield(v000,'HashLength'),v002=true;
return,end,v000.HashLength=v003;varargin(1)=[];end,[v000,v001,v002]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});end
function error_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@error_);end,if ...
isempty(v001),v001=validate_print_to__options(struct);end,v001 =...
parse_warning_error_redirect_options( v001 );[v002,v003,v004,v005,v006]=...
parse_warning_error_redirect_inputs( varargin{:});if v006,return,end,v007=struct('identifier',...
v002,'message',v003,'stack',v004);if v001.boolean.obj,v008=v003;while v008(end)==10,v008(end)=...
'';end,if any(v008==10),v008=char2cellstr(['Error: ' v008]);else,v008=['Error: ' v008];end,for ...
v009=v001.obj(:).',try set(v009,'String',v008);catch,end,end,end,if v001.boolean.fid,for v010=...
v001.fid(:).',try fprintf(v010,'Error: %s\n%s',v003,v005);catch,end,end,end,if v001.boolean.fcn,...
if ismember(v000,{v004.name}),error('prevent recursion'),end,for v011=v001.fcn(:).',if ...
isfield(v011,'data'),try feval(v011.h,'error',v007,v011.data);catch,end,else,try feval(v011.h,...
'error',v007);catch,end,end,end,end,rethrow(v007),end
function [v000,v001]=get_trace(v002,v001),if nargin==0,v002=1;end,if nargin<2, v001=dbstack;end,...
v001(1:v002)=[];if ~isfield(v001,'file'),for v003=1:numel(v001),v004=v001(v003).name;if ...
strcmp(v004(end),')'),v005=strfind(v004,'(');v006=v004( (v005(end)+1):(end-1) );v007=...
v004(1:(v005(end)-2));else,v007=v004;[v008,v006]=fileparts(v004);end,[v008,v001(v003).file]=...
fileparts(v007);v001(v003).name=v006;end,end,persistent v009,if isempty(v009),v009=...
exist('OCTAVE_VERSION','builtin');end,if v009,for v003=1:numel(v001),[v008,v001(v003).file]=...
fileparts(v001(v003).file);end,end,v010=v001;v011='>';v000=cell(1,numel(v010)-1);for v003=...
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);if v003==numel(v010),...
v010(v003).file='';end,if strcmp(v010(v003).file,v010(v003).name),v010(v003).file='';end,if ...
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file '>'];end,v000{v003}=...
sprintf('%c In %s%s (line %d)\n',v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=' ';
end,v000=horzcat(v000{:});end
function v000=bsxfun_plus(v001,v002),try v000=v001+v002;catch,try v000=bsxfun(@plus,v001,v002);
catch,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,...
max(1,v003./v004));v000=v001+v002;end,end,end
function v000=cast_to_uint16_vector(v000,v001),if isa(v000,'uint16'),v002='uint16';v003=...
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];return,...
end,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];end
function v000=ifversion(v001,v002,v003,v004,v005),persistent v006 v007 v008,if isempty(v006),...
v008=exist('OCTAVE_VERSION', 'builtin');v006=version;v009=strfind(v006,'.');if numel(v009)~=1,...
v006(v009(2):end)='';v009=v009(1);end,v006=[str2double(v006(1:(v009-1))) ...
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ 'R13' 605;
'R13SP1' 605;'R13SP2' 605;'R14' 700;'R14SP1' 700;'R14SP2' 700;'R14SP3' 701;'R2006a' 702;
'R2006b' 703;'R2007a' 704;'R2007b' 705;'R2008a' 706;'R2008b' 707;'R2009a' 708;'R2009b' 709;
'R2010a' 710;'R2010b' 711;'R2011a' 712;'R2011b' 713;'R2012a' 714;'R2012b' 800;'R2013a' 801;
'R2013b' 802;'R2014a' 803;'R2014b' 804;'R2015a' 805;'R2015b' 806;'R2016a' 900;'R2016b' 901;
'R2017a' 902;'R2017b' 903;'R2018a' 904;'R2018b' 905;'R2019a' 906;'R2019b' 907;'R2020a' 908;
'R2020b' 909;'R2021a' 910;'R2021b' 911};end,if v008,if nargin==2,...
warning('HJW:ifversion:NoOctaveTest',['No version test for Octave was provided.',char(10),...
'This function might return an unexpected outcome.']),if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,elseif nargin==4,[v001,v010]=deal(v003,v004);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);else,[v001,v010]=deal(v004,v005);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);end,else,if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,end,switch v001,case '==', v000= v006 == v010;case ...
'<' , v000= v006 < v010;case '<=', v000= v006 <= v010;case '>' , v000= v006 > v010;case '>=', ...
v000= v006 >= v010;end,end
function v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,...
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,...
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];end
function v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);if ...
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;end,v002=uint16(2.^(15:-1:0))';v000=...
uint16(reshape(v000,16,[]));try v000=v000.*v002;catch,v000=double(v000).*repmat(double(v002),[1 ...
size(v000,2)]);v000=uint16(v000);end,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,...
2^16))];end
function v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
persistent v003,if isempty(v003),v003=ifversion('>=','R2010b','Octave','>',0);end,v004=...
class(v000);v005=~v001.cast_int64_double && v003 && v004(end)=='4';if ~v005,if ...
any(abs(double(v000(:)))>2^52),warning_(v001,'HJW:ComputeNonCryptHash:int64rounding',...
['int64 and uint64 will be rounded pre-R2010b, resulting in rounding.',char(10),...
'This will result in a hash that is different from newer releases.']),end,end,if v005,if ...
v004(1)~='u',v006=v000>0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=...
uint64(v000(v006))+uint64(v007)+1;v000=v008;end,elseif v004(1)~='u',v000=...
double(v000)-double(eval([v004 '(-inf)']));else,v000=double(v000);end,switch v004(end),case '8',...
if mod(numel(v000),2),v000(end+1)=0;end,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);case '6',v000=uint16(v000);case '2',v009=floor(v000/2^16);v009=v009.';v010=...
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));case '4',v011=v000;v012=...
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=...
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));end,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];end
function v000=char2cellstr(v001,v002),v003=isa(v001,'char');v001=int32(v001);if nargin<2,if ...
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;end,...
v001(v001==10)=-10;else,for v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),...
int32(-10));end,end,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);for v004=...
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);end,if v003,...
for v004=1:numel(v000),v000{v004}= char(v000{v004});end,else,for v004=1:numel(v000),v000{v004}=...
uint32(v000{v004});end,end,end
function v000=CharIsUTF8,persistent v001,if isempty(v001),if exist('OCTAVE_VERSION','builtin')~=...
0,v002=struct('w',warning('off','all'));[v002.msg,v002.ID]=lastwarn;v001=~isequal(8364,...
double(char(8364)));warning(v002.w);lastwarn(v002.msg,v002.ID);else,v001=false;end,end,v000=...
v001;end
function v000=ComputeNonCryptHash(v001,varargin),if nargin<1,...
error('HJW:ComputeNonCryptHash:InputIncorrect','At least 1 input required.'),end,if nargin==2 ...
&& isa(varargin{1},'struct') && varargin{1}.SkipInputParse,v002=varargin{1};else,[v003,v002,...
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});if ~v003,rethrow(v004),end,end,...
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;try v004=[];v001=...
cast_to_uint16_vector(v001,v002);catch v004;if isempty(v004),v004=lasterror;end,if ...
strcmp(v004.identifier,'MATLAB:nomem'),error_(v002.print_to,v004),else,if isfield(v002,'debug') ...
&& v002.debug,v007=sprintf('\n[original error: %s %s]',v004.identifier,v004.message);else,v007=...
'';end,error_(v002.print_to,'HJW:ComputeNonCryptHash:UnwindFailed',...
['The nested input contains an unsupported data type.' v007]),end,end,if mod(numel(v001),...
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];end,if ...
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=...
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');else,v001=...
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=...
circshift_by_col(v001);end,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=...
ComputeNonCryptHash_logical_to_uint16(v001);if v002.isSaltCall,v000=v001;return,end,v001=...
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=...
reshape(v000.',1,[]);end
function v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);for v003=...
1:numel(v000),if numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);continue,end,switch class(v000{v003}),case {'double','single'},v000{v003}=...
cast_to_uint16_vector__floats(v000{v003});case 'logical',v000{v003}=...
cast_to_uint16_vector__logical(v000{v003});case {'uint8','uint16','uint32','uint64','int8',...
'int16','int32','int64'},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);case 'char',...
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);case 'string',v000{v003}=...
cast_to_uint16_vector__string(v000{v003},v001);case 'cell',v000{v003}=...
cast_to_uint16_vector__cell(v000{v003},v001);case 'struct',v000{v003}=...
cast_to_uint16_vector__struct(v000{v003},v001);case {'gpuArray','tall'},v000{v003}=...
cast_to_uint16_vector__cell({gather(v000{v003})},v001);otherwise,error_(v001.print_to,...
'HJW:cast_to_uint16_vector:nosupport','Unsupported data type in nested variable'),end,end,v000=...
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__char(v000,v001),persistent v002,if isempty(v002),v002 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if v002 && v001.re_encode_char,v003 = size(v000,1)==...
numel(v000);if v003,v000=v000.';end,v000=cellstr(v000);for v004=1:numel(v000),v000{v004}=...
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);end,v005=cellfun('length',v000);
v006=max(v005);for v004=find(v005<v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(' ');
end,v000=cell2mat(v000);if v003,v000=v000.';end,end,v007=size(v000).';v000=v000(:);v000=...
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];end
function v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=...
fieldnames(v000);v004=cell(2,numel(v003));for v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,...
v005}={v000.(v003{v005})};end,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__string(v000,v001),if v001.string_to_cellstr,v000=...
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);else,v000=char(v000);v000=...
cast_to_uint16_vector__char(v000,v001);end,end
function [v000,v001,v002,v003,v004]=parse_warning_error_redirect_inputs(varargin),v004=false;if ...
nargin==1,if isa(varargin{1},'struct') || isa(varargin{1},'MException'),v005=varargin{1};if ...
numel(v005)==0,v004=true;[v000,v001,v002,v003]=deal('');return,end,try v002=v005.stack;v003=...
get_trace(0,v002);catch,[v003,v002]=get_trace(3);end,v000=v005.identifier;v001=v005.message;
v006='Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback(';if ...
isa(v005,'struct') && numel(v001)>numel(v006) && strcmp(v006,v001(1:numel(v006))),...
v001(1:find(v001==10,1))='';end,else,[v003,v002]=get_trace(3);[v000,v001]=deal('',varargin{1});
end,else,[v003,v002]=get_trace(3);if ~isempty(strfind(varargin{1},'%')),v000='';v007=...
varargin(2:end);v001=sprintf(varargin{1},v007{:});else,v000=varargin{1};v001=varargin{2};if ...
nargin>2,v007=varargin(3:end);v001=sprintf(v001,v007{:});end,end,end,end
function v000=parse_warning_error_redirect_options(v000),if ~isfield(v000,'boolean'),...
v000.boolean=struct;end,if ~isfield(v000.boolean,'con') || isempty(v000.boolean.con),...
v000.boolean.con=false;end,if ~isfield(v000.boolean,'fid') || isempty(v000.boolean.fid),...
v000.boolean.fid=isfield(v000,'fid');end,if ~isfield(v000.boolean,'obj') || ...
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,'obj');end,if ~isfield(v000.boolean,...
'fcn') || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,'fcn');end,end
function v000=PatternReplace(v001,v002,v003),v000=v001(:)';if numel(v002)==0,v004=...
false(size(v001));elseif numel(v003)>numel(v002),error('not implemented (padding required)'),...
else,v004=true(size(v001));for v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006<1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 & v007;if ~any(v004),break,...
end,end,end,v006=find(v004);if ~isempty(v006),for v005=1:numel(v003),v000(v006+v005-1)=...
v003(v005);end,if numel(v003)==0,v005=0;end,if numel(v002)>v005,v006=v006(:);v008=...
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];end,end,end
function varargout=regexp_outkeys(v000,v001,varargin),if nargin<2,...
error('HJW:regexp_outkeys:SyntaxError','No supported syntax used: at least 3 inputs expected.'),...
end,if ~(ischar(v000) && ischar(v001)),error('HJW:regexp_outkeys:InputError',...
'All inputs must be char vectors.'),end,if nargout>nargin,error('HJW:regexp_outkeys:ArgCount',...
'Incorrect number of output arguments. Check syntax.'),end,persistent v002 v003,if ...
isempty(v002),v002.match = ifversion('<','R14','Octave','<',4);v002.split = ifversion('<',...
'R2007b','Octave','<',4);v004=fieldnames(v002);v003=...
['Extra regexp output type not implemented,',char(10),'only the following',...
' types are implemented:',char(10),sprintf('%s, ',v004{:})];v003((end-1):end)='';v002.any = ...
v002.match || v002.split;end,if v002.any || nargin==2,[v005,v006]=regexp(v000,v001);end,if ...
nargin==2,varargout={v005,v006};return,end,varargout=cell(size(varargin));for v007=1:(nargin-2),...
if ~ischar(varargin{v007}),error('HJW:regexp_outkeys:InputError',...
'All inputs must be char vectors.'),end,switch lower(varargin{v007}),case 'match',if v002.match,...
v008=cell(1,numel(v005));for v009=1:numel(v005),v008{v009}=v000(v005(v009):v006(v009));end,else,...
[v008,v005,v006]=regexp(v000,v001,'match');end,varargout{v007}=v008;case 'split',if v002.split,...
v010=cell(1,numel(v005)+1);v011=[v005 numel(v000)+1];v012=[0 v006];for v009=1:numel(v011),...
v010{v009}=v000((v012(v009)+1):(v011(v009)-1));end,else,[v010,v005,v006]= regexp(v000,v001,...
'split');end,varargout{v007}=v010;case 'start',varargout{v007}=v005;case 'end',varargout{v007}=...
v006;otherwise,error('HJW:regexp_outkeys:NotImplemented',v003),end,end,if nargout>v007,...
varargout(v007+[1 2])={v005,v006};end,end
function [v000,v001]=test_if_scalar_logical(v001),persistent v002,if isempty(v002),v002={true,...
false;1,0;'on','off';'enable','disable';'enabled','disabled'};try v002(end+1,:)=...
eval('{"on","off"}');catch,end,end,v000=true;try if isa(v001,'char') || isa(v001,'string'),try ...
v001=lower(v001);catch,end,end,for v003=1:size(v002,1),for v004=1:2,if isequal(v001,v002{v003,...
v004}),v001=v002{1,v004};return,end,end,end,if isa(v001,'matlab.lang.OnOffSwitchState'),v001=...
logical(v001);return,end,catch,end,v000=false;end
function v000=circshift_by_col(v000),persistent v001,v002=size(v000);if isempty(v001) || ...
any(size(v001)<v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),...
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);if ...
prod(v002)<=1000,v001{v002(1),v002(2)}=v006;end,else,v006=v001{v002(1),v002(2)};end,v000=...
v000(v006);end
function [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =...
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=...
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=...
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 & v002>0)=...
9218868437227405312;v000(v008 & v002<0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=...
0;v001(v008)=0;end
function v000=unicode_to_char(v001,v002),persistent v003,if isempty(v003),v003 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if nargin==1,v002=~CharIsUTF8;end,if v002,if ...
all(v001<65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,v006]=...
unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);end,if ~v003,v000=char(v000);
end,else,if all(v001<128),v000=char(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,...
v006]=unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=...
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);
v000=char(v000);end,end,end
function v000=unicode_to_UTF16(v001),if v001<65536,v000=v001;return,end,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec(['110110' v002(1:10);'110111' v002(11:20)]).';end
function [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001='success';v002=...
struct('identifier','HJW:UTF8_to_unicode:notUTF8','message','Input is not UTF-8.');persistent ...
v004,if isempty(v004),v004 = exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if any(v000>255),v001=...
'error';if v003,return,end,elseif all(v000<128),return,end,for v005=4:-1:2,v006=...
bin2dec([repmat('1',1,v005) repmat('0',1,8-v005)]);v007=v000>=v006 & v000<256;if any(v007),v007=...
find(v007);v007=v007(:).';if numel(v000)<(max(v007)+v005-1),v001='error';if v003,return,end,...
v007( (v007+v005-1)>numel(v000) )=[];end,if ~isempty(v007),v008=bsxfun_plus(v007 , ...
(0:(v005-1)).' );v008=v008.';v007=v000(v008);end,else,v007=[];end,v009=[repmat('1',1,v005-1) ...
repmat('10',1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);if numel(v007)>0,v007=...
unique(v007,'rows');v011=mat2cell(v007,ones(size(v007,1),1),v005);for v012=1:numel(v011),v013=...
dec2bin(double(v011{v012}))';if ~strcmp(v009,v013(v010)),v001='error';if v003,return,end,...
continue,end,v013(v010)='';if ~v004,v014=uint32(bin2dec(v013 ));else,v014=...
uint32(bin2dec(v013.'));end,v000=PatternReplace(v000,v011{v012},v014);end,end,end,end
function v000=unicode_to_UTF8(v001),if numel(v001)>1,...
error('this should only be used for single characters'),end,if v001<128,v000=v001;return,end,...
persistent v002,if isempty(v002),v002=struct;v002.limits.lower=hex2dec({'0000','0080','0800', ...
'10000'});v002.limits.upper=hex2dec({'007F','07FF','FFFF','10FFFF'});v002.scheme{2}=...
'110xxxxx10xxxxxx';v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}=...
'1110xxxx10xxxxxx10xxxxxx';v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}=...
'11110xxx10xxxxxx10xxxxxx10xxxxxx';v002.scheme{4}=reshape(v002.scheme{4}.',8,4);for v003=2:4,...
v002.scheme_pos{v003}=find(v002.scheme{v003}=='x');v002.bits(v003)=numel(v002.scheme_pos{v003});
end,end,v004=find(v002.limits.lower<=v001 & v001<=v002.limits.upper);v000=v002.scheme{v004};
v005=v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=...
bin2dec(v000.').';end
function [v000,v001,v002]=UTF8_to_unicode(v003,v004),if nargin<2,v004=[];end,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);if strcmp(v006,...
'success'),v001=true;v000=v002;elseif strcmp(v006,'error'),v001=false;if v005,error_(v004,v007),...
end,v000=v003;end,end
function v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=...
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);if ...
v001.Version>1,v004=v004(end:-1:1);end,v000=mod(double(v000).*double(v004),1+2^16);v000=...
uint16(v000);end
function v000=ComputeNonCryptHash_dec2hex(v001),persistent v002,if isempty(v002),v002=...
upper(dec2hex(0:(-1+2^16),4));end,v001=double(v001)+1;v000=v002(v001,:);end
function [v000,v001]=validate_print_to__options(v002,v001),if nargin<2,v001=struct;end,if ...
~isfield(v002,'print_to_con'),v002.print_to_con=[];end,if ~isfield(v002,'print_to_fid'),...
v002.print_to_fid=[];end,if ~isfield(v002,'print_to_obj'),v002.print_to_obj=[];end,if ...
~isfield(v002,'print_to_fcn'),v002.print_to_fcn=[];end,v003=true;v000=struct;v004=...
v002.print_to_fid;if isempty(v004),v000.boolean.fid=false;v000.fid=[];else,v003=false;
v000.boolean.fid=true;v000.fid=v004;for v005=1:numel(v004),try v006=ftell(v004(v005));catch,...
v006=-1;end,if v004(v005)~=1 && v006==-1,v001.message=['Invalid print_to_fid parameter:',...
char(10),'should be a valid file identifier or 1.'];v000=[];return,end,end,end,v004=...
v002.print_to_obj;if isempty(v004),v000.boolean.obj=false;v000.obj=[];else,v003=false;
v000.boolean.obj=true;v000.obj=v004;for v005=1:numel(v004),try v007=get(v004(v005),'String' );
set( v004(v005),'String','' );set( v004(v005),'String',v007);catch,v001.message=...
['Invalid print_to_obj parameter:',char(10),...
'should be a handle to an object with a writeable String property.'];v000=[];return,end,end,end,...
v004=v002.print_to_fcn;if isempty(v004),v000.boolean.fcn=false;v000.fcn=[];else,v003=false;try ...
for v005=1:numel(v004),if ~ismember(class(v004(v005).h),{'function_handle','inline'}) || ...
numel(v004(v005).h)~=1,error('trigger error'),end,end,catch,v001.message=...
['Invalid print_to_fcn parameter:',char(10),...
'should be a struct with the h field containing a function handle,',char(10),...
'anonymous function or inline function.'];v000=[];return,end,end,v004=v002.print_to_con;if ...
isempty(v004),v000.boolean.con=v003;else,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
if ~v008,v001.message=['Invalid print_to_con parameter:',char(10),...
'should be a scalar logical.'];v000=[];return,end,end,end
function warning_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@warning_);end,...
if isempty(v001),v001=validate_print_to__options(struct);end,v001 =...
parse_warning_error_redirect_options( v001 );[v002,v003,v004,v005,v006]=...
parse_warning_error_redirect_inputs( varargin{:});if v006,return,end,v007=struct('identifier',...
v002,'message',v003,'stack',v004);if v001.boolean.con,if ~isempty(v002),warning(v002,'%s',v003),...
else,warning(v003), end,else,if ~isempty(v002),lastwarn(v003,v002); else,lastwarn(v003),end,end,...
if v001.boolean.obj,v008=v003;while v008(end)==10,v008(end)=[];end,if any(v008==10),v008=...
char2cellstr(['Warning: ' v008]);else,v008=['Warning: ' v008];end,set(v001.obj,'String',v008),...
for v009=v001.obj(:).',try set(v009,'String',v008);catch,end,end,end,if v001.boolean.fid,for ...
v010=v001.fid(:).',try fprintf(v010,'Warning: %s\n%s',v003,v005);catch,end,end,end,if ...
v001.boolean.fcn,if ismember(v000,{v004.name}),error('prevent recursion'),end,for v011=...
v001.fcn(:).',if isfield(v011,'data'),try feval(v011.h,'warning',v007,v011.data);catch,end,else,...
try feval(v011.h,'warning',v007);catch,end,end,end,end,end

##### SOURCE END #####
--></body></html>